#include <unistd.h>
#include <cstdlib>
#include <stdexcept>
#include <thread>
#include <ctime>

#include "logging.h"
#include "TError.h"
#include "TMessage.h"
#include "DataItems/TDataItem.h"
#include "eNET-AIO16-16F.h"
#include "adc.h"

const std::vector<TMessageId> ValidMessageIDs{
	// to server
	'Q', // query/read
	'C', // config/write
	'M', // generic Message; bundle of Actions
		 // to client
	'R', // Response, no errors
	'X', // response, error, syntaX
	'E', // response, Error, semantic (e.g., "out of range" in an argument ), or operational (e.g., hardware timeout)
	'H', // Hello
};

#pragma region TMessage implementation
TCheckSum TMessage::calculateChecksum(TBytes Message)
{
	LOG_IT;

	TCheckSum checksum = 0;
	for (__u8 aByte : Message)
		checksum += aByte;
	return checksum;
}

bool TMessage::isValidMessageID(TMessageId MessageId)
{
	bool result = false;
	for (uint i = 0; i < sizeof(ValidMessageIDs) / sizeof(TMessageId); i++)
	{
		if (ValidMessageIDs[i] == MessageId)
		{
			result = true;
			break;
		}
	}
	return result;
}

// Checks the Payload for well-formedness
// returns 0 if the Payload is well-formed
// this means that all the Data Items are well formed and the total size matches the expectation
// "A Message has an optional Payload, which is a sequence of zero or more Data Items"
TError TMessage::validatePayload(TBytes Payload)
{
	LOG_IT;

	// WARN: Does not seem to work as expected when parsing multiple DataItems
	TError result = ERR_SUCCESS;
	if (Payload.size() == 1) // one-byte Payload is "the checksum byte".
		return result;

	if (Payload.size() == 0) // zero-length Payload size is a valid payload
		return ERR_MSG_DATAITEM_TOO_SHORT;
	if (Payload.size() < sizeof(DataItemIds)+sizeof(TDataItemLength))
		return ERR_MSG_DATAITEM_TOO_SHORT;

	TDataItemHeader *head = (TDataItemHeader *)Payload.data();

	__u32 DataItemSize = sizeof(TDataItemHeader) + head->dataLength;
	if (DataItemSize > Payload.size())
	{
		Error("--ERR: data item thinks it is longer than payload, disize: " + std::to_string(DataItemSize) + ", psize: " + std::to_string(Payload.size()));
		result = ERR_MSG_PAYLOAD_DATAITEM_LEN_MISMATCH;
	}
	else
	{
		TBytes DataItem = slicing(Payload, 0, DataItemSize);
		result = TDataItem::validateDataItem(DataItem);
		if (result == 0) // if the Data Item is well-formed, check the next one
		{
			Payload.erase(Payload.cbegin(), Payload.cbegin() + DataItemSize);
			if (Payload.size() > 0)
				result = validatePayload(Payload);
		}
	}

	return result;
}

// Checks the Message for well-formedness
// returns 0 if Message is well-formed
TError TMessage::validateMessage(TBytes buf) // "NAK()" is shorthand for return error condition etc
{
	LOG_IT;

	Trace("ENTER: RAW Message: ", buf);
	if (buf.size() < minimumMessageLength)
		return ERR_MSG_TOO_SHORT; // NAK(received insufficient data, yet) until more data (the rest of the Message/header) received?

	TMessageHeader *head = (TMessageHeader *)buf.data();

	if (!isValidMessageID(head->type))
		return ERR_MSG_ID_UNKNOWN; // NAK(invalid MessageId Category byte)

	__u32 statedMessageLength = minimumMessageLength + head->payload_size;
	if (buf.size() < statedMessageLength)
		return ERR_MSG_LEN_MISMATCH; // NAK(received insufficient data, yet) until more data

	TCheckSum checksum = TMessage::calculateChecksum(buf);

	if (__valid_checksum__ != checksum)
	{
		Error("calculated csum: " + std::to_string(checksum) + " ERROR should be zero\n");
		return ERR_MSG_CHECKSUM; // NAK(invalid checksum)
	}
	TBytes payload = buf;
	payload.erase(payload.cbegin(), payload.cbegin() + sizeof(TMessageHeader));

	TError validPayload = validatePayload(payload);
	if (validPayload != 0)
		return validPayload;

	return 0; // valid message
}
/* A Payload consists of zero or more DataItems
 * This function parses an array of bytes that is supposed to be a Payload
 * ...then returns a vector of those TDataItems and sets result to indicate error/success
 */
TPayload TMessage::parsePayload(TBytes Payload, __u32 payload_length, TError &result)
{
	LOG_IT;

	TPayload dataItems; // an empty vector<>
	result = ERR_SUCCESS;
	if (payload_length == 0)
	{ // zero-length payload size is a valid payload
		return dataItems;
	}

	TBytes DataItemBytes = Payload; // pointer to start of byte[] Payload
	Debug("Parsing Each Data Item in Payload generated by TMessage::FromBytes");
	while (payload_length >= sizeof(TDataItemHeader))
	{
		TDataItemHeader *head = (TDataItemHeader *)DataItemBytes.data();
		// DataItemLength is the size of the Data Item, including the size of the Data Item Length
		// + Data Item ID, and the Data Item's payload's bytelength
		__u32 DataItemLength = sizeof(TDataItemHeader) + head->dataLength; // DataItem[3] is payload length
		if (DataItemLength > payload_length)
		{
			result = ERR_MSG_PAYLOAD_DATAITEM_LEN_MISMATCH;
			Error("TMessage::parsePayload: DataItemLength > payload_length returned error " + std::to_string(result) + ", " + err_msg[-result]);
			break;
		}

		PTDataItem item = TDataItem::fromBytes(DataItemBytes, result);
		if (result != ERR_SUCCESS)
		{
			Error("TMessage::parsePayload: DIAG::fromBytes returned error " + std::to_string(result) + ", " + err_msg[-result]);
			break;
		}
		dataItems.push_back(item);

		// remove the bytes from the Payload that were parsed into 'item'
		DataItemBytes.erase(DataItemBytes.cbegin(), DataItemBytes.cbegin() + DataItemLength);
		payload_length -= DataItemLength;
	}
	return dataItems;
}

TMessage TMessage::FromBytes(TBytes buf, TError &result)
{
	LOG_IT;

	result = ERR_SUCCESS;
	//Debug("Received: ", buf);

	auto siz = buf.size();
	if (siz < minimumMessageLength)
	{
		result = ERR_MSG_TOO_SHORT;
		Error("Message Size < minimumMessageLength (" + std::to_string(siz) + " < " + std::to_string(minimumMessageLength));
		return TMessage(_INVALID_MESSAGEID_); // NAK(received insufficient data, yet) until more data (the rest of the Message/header) received?
	}
	TMessageHeader *head = (TMessageHeader *)buf.data();

	if (!isValidMessageID(head->type))
	{
		result = ERR_MSG_ID_UNKNOWN; // NAK(invalid MessageID Category byte)
		Error("TMessage::FromBytes: detected invalid MId: " + std::to_string(result) + ", " + err_msg[-result]);
		return TMessage();
	}
	__u32 statedMessageLength = minimumMessageLength + head->payload_size;
	if (siz < statedMessageLength)
	{
		result = ERR_MSG_LEN_MISMATCH; // NAK(received insufficient data, yet) until more data
		return TMessage();
	}

	TPayload dataItems;
	if (head->payload_size > 0)
	{
		Trace("TMessage::FromBytes: Payload is " + std::to_string(head->payload_size) + " bytes");
		TBytes payload = buf;
		payload.erase(payload.cbegin(), payload.cbegin() + sizeof(TMessageHeader));
		Trace("TMessage::FromBytes generated payload: ", payload);
		dataItems = parsePayload(payload, head->payload_size, result);
		Trace("parsePayload returned " + std::to_string(dataItems.size()) + " with resultCode " + std::to_string(result));
	}

	TCheckSum checksum = calculateChecksum(buf);
	if (__valid_checksum__ != checksum)
	{
		result = ERR_MSG_CHECKSUM; // NAK(invalid checksum)
		Error("TMessage::FromBytes: invalid checksum " + std::to_string(checksum) + " ERROR should be zero\n");
		return TMessage();
	}

	TMessage message = TMessage(head->type, dataItems);
	Trace("TMessage::FromBytes: TMessage constructed...Payload DataItem Count: " + std::to_string(message.DataItems.size()));
	return message;
}

TMessage::TMessage(TMessageId MId)
{
	LOG_IT;

	this->setMId(MId);
}

TMessage::TMessage(TMessageId MId, TPayload Payload)
{
	LOG_IT;

	this->setMId(MId);
	for (auto one : Payload)
	{
		DataItems.push_back(one);
	}
	// DataItems = Payload;
}

TMessage::TMessage(TBytes Msg)
{
	LOG_IT;

	TError result = ERR_SUCCESS;
	*this = TMessage::FromBytes(Msg, result); // CODE SMELL: this technique makes me question my existence
	if (result != ERR_SUCCESS)
		throw std::logic_error(err_msg[-result]);
}

TMessageId TMessage::getMId()
{
	return this->Id;
}

TCheckSum TMessage::getChecksum(bool bAsReply)
{
	return TMessage::calculateChecksum(this->AsBytes(bAsReply));
}

TMessage &TMessage::setMId(TMessageId ID)
{
	if (!isValidMessageID(ID))
		throw std::logic_error("ERR_MSG_ID_UNKNOWN"); // TODO: FIX using TError
	this->Id = ID;

	return *this;
}

TMessage &TMessage::addDataItem(PTDataItem item)
{
	LOG_IT;

	this->DataItems.push_back(item);
	return *this;
}

void TMessage::appendLengthBytes(TBytes& bytes, TMessagePayloadSize length)
{
	if (length>0)
    for (uint i = 0; i < sizeof(TMessagePayloadSize); i++)
    {
        __u8 lsb = length & 0xFF;
        bytes.push_back(lsb);
        length >>= 8;
    }
}
void TMessage::appendPayloadLengthAndItems(TBytes& bytes, bool bAsReply)
{
    TMessagePayloadSize payloadLength = 0;
    TBytes payloadBytes;

    for (auto item : this->DataItems)
    {
        TBytes itemBytes = item->AsBytes(bAsReply);
        payloadBytes.insert(end(payloadBytes), begin(itemBytes), end(itemBytes));
        payloadLength += itemBytes.size();
    }

    appendLengthBytes(bytes, payloadLength);
    bytes.insert(end(bytes), begin(payloadBytes), end(payloadBytes));
}
TBytes TMessage::AsBytes(bool bAsReply)
{
    LOG_IT;
    Trace("AsBytes"+ bAsReply?", as Reply":", NOT reply");

    TBytes bytes;
    bytes.push_back(this->Id);
    appendPayloadLengthAndItems(bytes, bAsReply);

    TCheckSum csum = -calculateChecksum(bytes);
    bytes.push_back(csum); // WARN: only works because TCheckSum == __u8
    Trace("Built: ", bytes);

    return bytes;
}


std::string TMessage::AsString(bool bAsReply)
{
	LOG_IT;
	Trace("AsString, "+ bAsReply?"as Reply":"");
	std::stringstream dest;
	// TBytes raw = this->AsBytes(bAsReply);
	// Trace("TMessage, Raw Bytes: ", raw);
	//dest << "Message = MId:" << to_hex<__u8>(this->getMId()) << ", # DataItems: " << DataItems.size();
	dest << "Message = MId: '" << this->getMId() << "', # DataItems: " << DataItems.size();
	if (DataItems.size() != 0)
	{
		for (uint itemNumber = 0; itemNumber < DataItems.size(); itemNumber++)
		{
			PTDataItem item = this->DataItems[itemNumber];
			dest << '\n'
				 << "		   " << std::setw(2) << itemNumber + 1 << ": " << item->AsString(bAsReply);
		}
	}
	return dest.str();
}

#pragma endregion
